# Write-What-Where
This writeup is for the purpose of my understanding of the write-what-where exploit abusing the lack of checks in the `unlink` function for earlier linux kernel versions 
using `dlmalloc`. This is performed with ASLR off.

## Dynamic Memory
When you call functions like `malloc` or `calloc`, you are dynamically creating chunks of memory on the heap. Standard function calls will utilize the stack because the variables
will only last within the scope of the function and can be torn down afterwards. Dynamically creating memory allows for the data to persist longer and allow the programmer or
garbage collector to free the memory when the program no longer requires it.

## dlmalloc()
Doug Lea's malloc is one such memory allocator and includes `malloc`, `calloc`, `realloc`, `free`, and other utility functions. The structure for a chunk of allocated memory is
diagramed below. An in-use chunk of memory contains a `Previous Size` field of 4 bytes and a `Size` field of 4 bytes. The `Prev_Size` field will contain the value 0 until the
adjacent chunk, lower in memory, is freed and no longer in use. The field will then contain the size of the adjacent chunk. The `Size` field will contain, you guessed it, the 
size of the chunk itself. A free chunk will contain the `Prev_Size` and `Size` field along with a `Forward Pointer` and `Backward Pointer`. Free chunks create a doubly linked
list connecting all the free chunks together and when a chunk goes into use it unlinks itself from the list, or vice versa. More on this later.

```
   Chunk in use                             Free chunk
------------------                       ------------------
:    Prev_Size   : 4 bytes               :   Prev_Size    : 4 bytes
:----------------:                       :----------------:
:      Size      : 4 bytes               :      Size      : 4 bytes
:----------------:                       :----------------:
:      Data      : variable in size      :     FD_Ptr     : 4 bytes
:                :                       :----------------:
:                :                       :     BK_Ptr     : 4 bytes
:                :                       :----------------:
:                :                       :    Old_Data    : variable in size
:                :                       :                :
------------------                       ------------------
```
`Size` will pad itself out to the next double word boundary so that it controlls the 3 least significant bits which will act as flags. The bit we are interested
in is the least significant bit, which will contain the `Previous in Use` flag. When free is called on a chunk of memory, it will check the `Prev_Use` flag for a 1 or a 0. If the bit is set to 1, it knows the adjacent chunk is in use. If 0, it knows the chunk is free. There is a rule on the heap that no two adjacent chunks are allowed to both be free. If free is called on chunk1, it will check chunk2's `Prev_Use` bit and, if the bit is 0, it will merge chunk1 and chunk2 together.
```
                             Chunk 1                                                 Chunk 2 (Not in use)
-------------------------------------------------------------  -------------------------------------------------------------
: Prev_Size : Size |A|M|P|:  FD_Ptr  :  BK_Ptr  :  Old_Data :  :      Prev_Size      :       Size       :       Data       :  
-------------------------------------------------------------  -------------------------------------------------------------
```

